# this pulls in the dictionary generated by simple_crawler_modified.py
# and returns a doubly-linked ring of tnodes, one tnode for each unique url
# with pointer to starting url and fields for each tnode set to the default values

from fibheap import TreeNode
from simple_crawler import *
from prioqueue import *
from Queue import PriorityQueue

def from_dict_to_prioqueue_urlset(dict,starting_url) :
    prioq = PriorityQueue()
    urlset = set()
    #first key is going to be the start url -> initiate with 0 distance (key)
    is_start_url = True
    for key in dict:
        urlset.add(key.lower())
        if key.lower() == starting_url.lower() and is_start_url:
            key_tnode = TreeNode(0, key.lower())
            pq_push(prioq, key_tnode)
            is_start_url = False
        else:
            key_tnode = pq_member(prioq, key.lower())
            if key_tnode == None :
                key_tnode = TreeNode(float("inf"), key.lower())
                pq_push(prioq, key_tnode)
        # for each of the urls in its val, check if tnode already exists in circnode ring
        for val_url in dict[key]:
            urlset.add(val_url.lower())
            # if it doesn't exist, add the tnode
            val_tnode = pq_member(prioq, val_url.lower())
            if val_tnode == None :
                val_tnode = TreeNode(float("inf"), val_url.lower())
                pq_push(prioq, val_tnode)
            key_tnode.neighbors.append(val_tnode)
    print "\tmin key: %g, url: %s" % (
        prioq.queue[0].key, prioq.queue[0].self_url)
    print "\tsize of prioqueue: %d" % prioq.qsize()
    print "\tsize of dict: %d" % len(dict)
    return prioq, urlset


def build_dict(filename) :
    dictfile = open(filename, 'r')
    curr_key = curr_val = ''
    dict = {}
    new_key = False
    if dictfile == None :
        print "Could not open file."
    else :
        dictfile.seek(0)

    print "Reading file '%s'...." % dictfile.name

    for line in dictfile :
        line = line.split(' ')
        if len(line) > 2 :
            print >> sys.stderr, "Error: whitespace in URL from file\n"
            exit(1)

        if line[0] == "key" :
            curr_key = line[1].rstrip('\n')
            new_key = True
        elif line[0] == "val" :
            curr_val = line[1].rstrip('\n')
        else :
            print >> sys.stderr, "Error: invalid line read from file\n"
            exit(1)

        if (curr_val != '') and (curr_key == '') :
            print >> sys.stderr, "Error: read value from file with no key\n"
            exit(1)

        if new_key :
            dict[curr_key] = []
        else :
            dict[curr_key].append(curr_val)

        new_key = False
        
    print "Reached end of file."
    
    dictfile.close()
    return dict
    
def from_dict_to_fibheap_urlset(dict,starting_url,output_f) :

    fibheap = FibHeap()
    urlset = set()
    #first key is going to be the start url -> initiate with 0 distance (key)
    is_start_url = True
    for key in dict:
        urlset.add(key.lower())
        if key == starting_url and is_start_url:
            key_tnode = TreeNode(0, key.lower())
            fibheap.insert(key_tnode, output_f)
            is_start_url = False
        else:
            # check if tnode already exists in circnode ring
            key_tnode = fibheap.find_on_self_url(key.lower(),output_f)        
            # if it doesn't, add it
            if key_tnode == None :
                key_tnode = TreeNode(float("inf"), key.lower())
                fibheap.insert(key_tnode,output_f)
        # for each of the urls in its val, check if tnode already exists in circnode ring
        for val_url in dict[key]:
            urlset.add(val_url.lower())
            val_tnode = fibheap.find_on_self_url(val_url.lower(),output_f)
            # if it doesn't exist, add the tnode
            if val_tnode == None:
                val_tnode = TreeNode(float("inf"), val_url.lower())
                fibheap.insert(val_tnode,output_f)
            # the connect this val_url tnode to key tnode
            key_tnode.neighbors.append(val_tnode)
    return fibheap, urlset 
        
